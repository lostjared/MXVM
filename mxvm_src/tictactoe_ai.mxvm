program TicTacToe {
  section module { io }

  section data {
    string welcome       = "--- MXVM Tic-Tac-Toe ---\n"
    string prompt        = "Player %c, enter position (0-8): "
    string invalid_move  = "Invalid move. That spot is taken or out of bounds.\n"
    string win_msg       = "Player %c wins!\n"
    string draw_msg      = "It's a draw!\n"
    string input_buffer, 8
    string ai_msg        = "Computer chooses position %d\n"
    int    P_X           = 88
    int    P_O           = 79
    int    zdx           = 0        # for AI calculations
  }

  section object { game_board }

  section code {
  start:
    alloc game_board.board, 8, 9
    print welcome
    call game_board.init_board
    jmp game_loop

  game_loop:
    call game_board.print_board
    mov game_board.winner, 0
    call game_board.check_win
    cmp game_board.winner, 0
    jne game_over
    cmp game_board.turn, 9
    je draw
    mod game_board.temp, game_board.turn, 2
    cmp game_board.temp, 0
    je set_X
    mov game_board.current_player, P_O
    jmp player_turn

  set_X:
    mov game_board.current_player, P_X

  player_turn:
    cmp game_board.current_player, P_O
    je ai_move
    print prompt, game_board.current_player
    jmp get_player_input

  ai_move:
    # start from user's last move + 1, wrap at 9
    mov zdx, game_board.move
    add zdx, zdx, 1
    cmp zdx, 9
    jl ai_try
    mov zdx, 0

  ai_try:
    load game_board.temp, game_board.board, zdx, 8
    cmp game_board.temp, game_board.P_EMPTY
    je ai_choose
    add zdx, zdx, 1
    cmp zdx, 9
    jl ai_try
    mov zdx, 0
    jmp ai_try

  ai_choose:
    store P_O, game_board.board, zdx, 8
    print ai_msg, zdx
    add game_board.turn, game_board.turn, 1
    jmp game_loop

  get_player_input:
    getline input_buffer
    to_int game_board.move, input_buffer
    cmp game_board.move, 0
    jl invalid
    cmp game_board.move, 8
    jg invalid
    load game_board.temp, game_board.board, game_board.move, 8
    cmp game_board.temp, game_board.P_EMPTY
    jne invalid
    store game_board.current_player, game_board.board, game_board.move, 8
    add game_board.turn, game_board.turn, 1
    jmp game_loop

  invalid:
    print invalid_move
    jmp game_loop

  game_over:
    call game_board.print_board
    cmp game_board.winner, 1
    je x_wins
    print win_msg, P_O
    call game_board.release
    done

  x_wins:
    print win_msg, P_X
    call game_board.release
    done

  draw:
    call game_board.print_board
    print draw_msg
    call game_board.release
    done
  }
}

object game_board {
  section data {
    ptr    board           = null
    export int turn        = 0
    export int current_player = 0
    export int move        = 0
    export int winner      = 0
    export int P_EMPTY     = 46
    int    i               = 0
    export int temp        = 0
    int    v1              = 0
    int    v2              = 0
    int    v3              = 0
    string row_fmt         = "%c | %c | %c\n"
    string sep_line        = "- + - + - \n"
    int al = 0
    int bl = 0
    int cl = 0
    export int idx = 0
  }

  section code {
  function init_board:
    mov i, 0
  init_loop:
    cmp i, 9
    jge init_done
    store P_EMPTY, board, i, 8
    add i, i, 1
    jmp init_loop
  init_done:
    ret

  function print_board:
    load v1, board, 0, 8
    load v2, board, 1, 8
    load v3, board, 2, 8
    print row_fmt, v1, v2, v3
    print sep_line

    load v1, board, 3, 8
    load v2, board, 4, 8
    load v3, board, 5, 8
    print row_fmt, v1, v2, v3
    print sep_line

    load v1, board, 6, 8
    load v2, board, 7, 8
    load v3, board, 8, 8
    print row_fmt, v1, v2, v3
    ret

      function check_win:
    # Row 0 (cells 0,1,2)
    mov al, 0
    mov bl, 1
    mov cl, 2
    call check_line
    cmp winner, 0
    jne done_check

    # Row 1 (cells 3,4,5)
    mov al, 3
    mov bl, 4
    mov cl, 5
    call check_line
    cmp winner, 0
    jne done_check

    # Row 2 (cells 6,7,8)
    mov al, 6
    mov bl, 7
    mov cl, 8
    call check_line
    cmp winner, 0
    jne done_check

    # Col 0 (cells 0,3,6)
    mov al, 0
    mov bl, 3
    mov cl, 6
    call check_line
    cmp winner, 0
    jne done_check

    # Col 1 (cells 1,4,7)
    mov al, 1
    mov bl, 4
    mov cl, 7
    call check_line
    cmp winner, 0
    jne done_check

    # Col 2 (cells 2,5,8)
    mov al, 2
    mov bl, 5
    mov cl, 8
    call check_line
    cmp winner, 0
    jne done_check

    # Diagonal TL→BR (cells 0,4,8)
    mov al, 0
    mov bl, 4
    mov cl, 8
    call check_line
    cmp winner, 0
    jne done_check

    # Diagonal TR→BL (cells 2,4,6)
    mov al, 2
    mov bl, 4
    mov cl, 6
    call check_line

  done_check:
    ret

  function check_line:
    load v1, board, al, 8
    load v2, board, bl, 8
    load v3, board, cl, 8

    cmp v1, P_EMPTY
    je  check_line_end
    cmp v1, v2
    jne check_line_end
    cmp v1, v3
    jne check_line_end

    cmp v1, P_X
    je  set_x
    cmp v1, P_O
    je  set_o

  check_line_end:
    ret

  set_x:
    mov winner, 1
    ret

  set_o:
    mov winner, 2
    ret


  function check_line:
    load v1, board, al, 8
    load v2, board, bl, 8
    load v3, board, cl, 8
    cmp v1, P_EMPTY
    je end_line
    cmp v1, v2
    jne end_line
    cmp v1, v3
    jne end_line
    cmp v1, P_X
    je set_x
    cmp v1, P_O
    je set_o
  end_line:
    ret
  set_x:
    mov winner, 1
    ret
  set_o:
    mov winner, 2
    ret

  function release:
    free board
    ret
  }
}
