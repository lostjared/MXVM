program TicTacToe {
  section module { io }

  section data {
    string welcome       = "--- MXVM Tic-Tac-Toe ---\n"
    string prompt        = "Player %c, enter position (0-8): "
    string invalid_move  = "Invalid move. That spot is taken or out of bounds.\n"
    string win_msg       = "Player %c wins!\n"
    string draw_msg      = "It's a draw!\n"
    string input_buffer, 8
    string ai_msg        = "Computer chooses position %d\n"
    int    P_X           = 88
    int    P_O           = 79
    int    zdx           = 0        # for AI calculations
  }

  section object { game_board }

  section code {
  start:
    alloc game_board.board, 8, 9
    print welcome
    call game_board.init_board
    jmp game_loop

  game_loop:
    call game_board.print_board
    mov game_board.winner, 0
    call game_board.check_win
    cmp game_board.winner, 0
    jne game_over
    cmp game_board.turn, 9
    je draw
    mod game_board.temp, game_board.turn, 2
    cmp game_board.temp, 0
    je set_X
    mov game_board.current_player, P_O
    jmp player_turn

  set_X:
    mov game_board.current_player, P_X

  player_turn:
    cmp game_board.current_player, P_O
    je ai_move
    print prompt, game_board.current_player
    jmp get_player_input

  ai_move:
    # start from user's last move + 1, wrap at 9
    mov zdx, game_board.move
    add zdx, zdx, 1
    cmp zdx, 9
    jl ai_try
    mov zdx, 0

  ai_try:
    load game_board.temp, game_board.board, zdx, 8
    cmp game_board.temp, game_board.P_EMPTY
    je ai_choose
    add zdx, zdx, 1
    cmp zdx, 9
    jl ai_try
    mov zdx, 0
    jmp ai_try

  ai_choose:
    store P_O, game_board.board, zdx, 8
    print ai_msg, zdx
    add game_board.turn, game_board.turn, 1
    jmp game_loop

  get_player_input:
    getline input_buffer
    to_int game_board.move, input_buffer
    cmp game_board.move, 0
    jl invalid
    cmp game_board.move, 8
    jg invalid
    load game_board.temp, game_board.board, game_board.move, 8
    cmp game_board.temp, game_board.P_EMPTY
    jne invalid
    store game_board.current_player, game_board.board, game_board.move, 8
    add game_board.turn, game_board.turn, 1
    jmp game_loop

  invalid:
    print invalid_move
    jmp game_loop

  game_over:
    call game_board.print_board
    cmp game_board.winner, 1
    je x_wins
    print win_msg, P_O
    call game_board.release
    done

  x_wins:
    print win_msg, P_X
    call game_board.release
    done

  draw:
    call game_board.print_board
    print draw_msg
    call game_board.release
    done
  }
}

object game_board {
  section data {
    ptr    board           = null
    export int turn        = 0
    export int current_player = 0
    export int move        = 0
    export int winner      = 0
    export int P_EMPTY     = 46
    int    i               = 0
    export int temp        = 0
    int    v1              = 0
    int    v2              = 0
    int    v3              = 0
    string row_fmt         = "%c | %c | %c\n"
    string sep_line        = "- + - + - \n"
    int al = 0
    int bl = 0
    int cl = 0
    export int idx = 0
  }

  section code {
  function init_board:
    mov i, 0
  init_loop:
    cmp i, 9
    jge init_done
    store P_EMPTY, board, i, 8
    add i, i, 1
    jmp init_loop
  init_done:
    ret

  function print_board:
    load v1, board, 0, 8
    load v2, board, 1, 8
    load v3, board, 2, 8
    print row_fmt, v1, v2, v3
    print sep_line

    load v1, board, 3, 8
    load v2, board, 4, 8
    load v3, board, 5, 8
    print row_fmt, v1, v2, v3
    print sep_line

    load v1, board, 6, 8
    load v2, board, 7, 8
    load v3, board, 8, 8
    print row_fmt, v1, v2, v3
    ret

    function check_win:
    # — left column (Board[0][0], [0][1], [0][2])
    load v1, board, 0, 8
    load v2, board, 3, 8
    load v3, board, 6, 8
    cmp v1, P_X
    jne cw1_2
    cmp v2, P_X
    jne cw1_2
    cmp v3, P_X
    jne cw1_2
    mov winner, 1
    ret
  cw1_2:
    cmp v1, P_O
    jne cw2_2
    cmp v2, P_O
    jne cw2_2
    cmp v3, P_O
    jne cw2_2
    mov winner, 2
    ret
  cw2_2:

    # — top row (Board[0][0], [1][0], [2][0])
    load v1, board, 0, 8
    load v2, board, 1, 8
    load v3, board, 2, 8
    cmp v1, P_X
    jne cw3_2
    cmp v2, P_X
    jne cw3_2
    cmp v3, P_X
    jne cw3_2
    mov winner, 1
    ret
  cw3_2:
    cmp v1, P_O
    jne cw4_2
    cmp v2, P_O
    jne cw4_2
    cmp v3, P_O
    jne cw4_2
    mov winner, 2
    ret
  cw4_2:

    # — middle column (Board[0][1], [1][1], [2][1])
    load v1, board, 1, 8
    load v2, board, 4, 8
    load v3, board, 7, 8
    cmp v1, P_X
    jne cw5_2
    cmp v2, P_X
    jne cw5_2
    cmp v3, P_X
    jne cw5_2
    mov winner, 1
    ret
  cw5_2:
    cmp v1, P_O
    jne cw6_2
    cmp v2, P_O
    jne cw6_2
    cmp v3, P_O
    jne cw6_2
    mov winner, 2
    ret
  cw6_2:

    # — right column (Board[0][2], [1][2], [2][2])
    load v1, board, 2, 8
    load v2, board, 5, 8
    load v3, board, 8, 8
    cmp v1, P_X
    jne cw7_2
    cmp v2, P_X
    jne cw7_2
    cmp v3, P_X
    jne cw7_2
    mov winner, 1
    ret
  cw7_2:
    cmp v1, P_O
    jne cw8_2
    cmp v2, P_O
    jne cw8_2
    cmp v3, P_O
    jne cw8_2
    mov winner, 2
    ret
  cw8_2:

    # — middle row (Board[1][0], [1][1], [1][2])
    load v1, board, 3, 8
    load v2, board, 4, 8
    load v3, board, 5, 8
    cmp v1, P_X
    jne cw9_2
    cmp v2, P_X
    jne cw9_2
    cmp v3, P_X
    jne cw9_2
    mov winner, 1
    ret
  cw9_2:
    cmp v1, P_O
    jne cw10_2
    cmp v2, P_O
    jne cw10_2
    cmp v3, P_O
    jne cw10_2
    mov winner, 2
    ret
  cw10_2:

    # — bottom row (Board[2][0], [2][1], [2][2])
    load v1, board, 6, 8
    load v2, board, 7, 8
    load v3, board, 8, 8
    cmp v1, P_X
    jne cw11_2
    cmp v2, P_X
    jne cw11_2
    cmp v3, P_X
    jne cw11_2
    mov winner, 1
    ret
  cw11_2:
    cmp v1, P_O
    jne cw12_2
    cmp v2, P_O
    jne cw12_2
    cmp v3, P_O
    jne cw12_2
    mov winner, 2
    ret
  cw12_2:

    # — diagonal TL→BR (Board[0][0], [1][1], [2][2])
    load v1, board, 0, 8
    load v2, board, 4, 8
    load v3, board, 8, 8
    cmp v1, P_X
    jne cw13_2
    cmp v2, P_X
    jne cw13_2
    cmp v3, P_X
    jne cw13_2
    mov winner, 1
    ret
  cw13_2:
    cmp v1, P_O
    jne cw14_2
    cmp v2, P_O
    jne cw14_2
    cmp v3, P_O
    jne cw14_2
    mov winner, 2
    ret
  cw14_2:

    # — diagonal TR→BL (Board[0][2], [1][1], [2][0])
    load v1, board, 2, 8
    load v2, board, 4, 8
    load v3, board, 6, 8
    cmp v1, P_X
    jne cw15_2
    cmp v2, P_X
    jne cw15_2
    cmp v3, P_X
    jne cw15_2
    mov winner, 1
    ret
  cw15_2:
    cmp v1, P_O
    jne cw_done
    cmp v2, P_O
    jne cw_done
    cmp v3, P_O
    jne cw_done
    mov winner, 2
    ret

  cw_done:
    ret


  function check_line:
    load v1, board, al, 8
    load v2, board, bl, 8
    load v3, board, cl, 8
    cmp v1, P_EMPTY
    je end_line
    cmp v1, v2
    jne end_line
    cmp v1, v3
    jne end_line
    cmp v1, P_X
    je set_x
    cmp v1, P_O
    je set_o
  end_line:
    ret
  set_x:
    mov winner, 1
    ret
  set_o:
    mov winner, 2
    ret

  function release:
    free board
    ret
  }
}
