program TicTacToe {
  section module { io }
  section object { State, Board, Printer, Rules, Human, AI }

  section data {
    string welcome      = "--- MXVM Tic-Tac-Toe ---\n"
    string win_msg      = "Player %c wins!\n"
    string draw_msg     = "It's a draw!\n"
  }

  section code {
  start:
    alloc Board.board, 8, 9
    print welcome
    call Board.init
    jmp game_loop

  game_loop:
    call Printer.print_board
    mov State.winner, 0
    call Rules.check_win
    cmp State.winner, 0
    jne game_over
    cmp State.turn, 9
    je draw

    mod State.temp, State.turn, 2
    cmp State.temp, 0
    je set_X
    mov State.current_player, State.P_O
    jmp player_turn

  set_X:
    mov State.current_player, State.P_X

  player_turn:
    cmp State.current_player, State.P_O
    je ai_turn
    call Human.turn
    jmp game_loop

  ai_turn:
    call AI.turn
    jmp game_loop

  game_over:
    call Printer.print_board
    cmp State.winner, 1
    je x_wins
    print win_msg, State.P_O
    call Board.release
    done

  x_wins:
    print win_msg, State.P_X
    call Board.release
    done

  draw:
    call Printer.print_board
    print draw_msg
    call Board.release
    done
  }
}

object State {
  section data {
    export int P_X            = 88
    export int P_O            = 79
    export int P_EMPTY        = 46
    export int turn           = 0
    export int current_player = 0
    export int move           = 0
    export int winner         = 0
    export int temp           = 0
  }
}

object Board {
  section data {
    export ptr board = null
    int i = 0
  }

  section code {
  function init:
    mov i, 0
  init_loop:
    cmp i, 9
    jge init_done
    store State.P_EMPTY, board, i, 8
    add i, i, 1
    jmp init_loop
  init_done:
    ret

  function release:
    free board
    ret
  }
}

object Printer {
  section data {
    string row_fmt  = "%c | %c | %c\n"
    string sep_line = "- + - + - \n"
    int v1 = 0
    int v2 = 0
    int v3 = 0
  }

  section code {
  function print_board:
    load v1, Board.board, 0, 8
    load v2, Board.board, 1, 8
    load v3, Board.board, 2, 8
    print row_fmt, v1, v2, v3
    print sep_line

    load v1, Board.board, 3, 8
    load v2, Board.board, 4, 8
    load v3, Board.board, 5, 8
    print row_fmt, v1, v2, v3
    print sep_line

    load v1, Board.board, 6, 8
    load v2, Board.board, 7, 8
    load v3, Board.board, 8, 8
    print row_fmt, v1, v2, v3
    ret
  }
}

object Rules {
  section data {
    int a = 0
    int b = 0
    int c = 0
    int v1 = 0
    int v2 = 0
    int v3 = 0
  }

  section code {
  function check_win:
    mov a, 0
    mov b, 1
    mov c, 2
    call check_line
    cmp State.winner, 0
    jne done

    mov a, 3
    mov b, 4
    mov c, 5
    call check_line
    cmp State.winner, 0
    jne done

    mov a, 6
    mov b, 7
    mov c, 8
    call check_line
    cmp State.winner, 0
    jne done

    mov a, 0
    mov b, 3
    mov c, 6
    call check_line
    cmp State.winner, 0
    jne done

    mov a, 1
    mov b, 4
    mov c, 7
    call check_line
    cmp State.winner, 0
    jne done

    mov a, 2
    mov b, 5
    mov c, 8
    call check_line
    cmp State.winner, 0
    jne done

    mov a, 0
    mov b, 4
    mov c, 8
    call check_line
    cmp State.winner, 0
    jne done

    mov a, 2
    mov b, 4
    mov c, 6
    call check_line
  done:
    ret

  function check_line:
    load v1, Board.board, a, 8
    load v2, Board.board, b, 8
    load v3, Board.board, c, 8
    cmp v1, State.P_EMPTY
    je end_line
    cmp v1, v2
    jne end_line
    cmp v1, v3
    jne end_line
    cmp v1, State.P_X
    je set_x
    cmp v1, State.P_O
    je set_o
  end_line:
    ret
  set_x:
    mov State.winner, 1
    ret
  set_o:
    mov State.winner, 2
    ret
  }
}

object Human {
  section data {
    string prompt       = "Player %c, enter position (0-8): "
    string invalid_move = "Invalid move. That spot is taken or out of bounds.\n"
    string input_buffer, 8
    int    tmp = 0
  }

  section code {
  function turn:
    print prompt, State.current_player
  read_again:
    getline input_buffer
    to_int State.move, input_buffer
    cmp State.move, 0
    jl invalid
    cmp State.move, 8
    jg invalid
    load tmp, Board.board, State.move, 8
    cmp tmp, State.P_EMPTY
    jne invalid
    store State.current_player, Board.board, State.move, 8
    add State.turn, State.turn, 1
    ret
  invalid:
    print invalid_move
    jmp read_again
  }
}

object AI {
  section data {
    string ai_msg = "Computer chooses position %d\n"
    int zdx = 0
    int tmp = 0
  }

  section code {
  function turn:
    mov zdx, State.move
    add zdx, zdx, 1
    cmp zdx, 9
    jl try_slot
    mov zdx, 0
  try_slot:
    load tmp, Board.board, zdx, 8
    cmp tmp, State.P_EMPTY
    je choose
    add zdx, zdx, 1
    cmp zdx, 9
    jl try_slot
    mov zdx, 0
    jmp try_slot
  choose:
    store State.P_O, Board.board, zdx, 8
    print ai_msg, zdx
    add State.turn, State.turn, 1
    ret
  }
}
