program Tetris {
    section module { sdl }

    section data {
        string title      = "MXVM SDL Tetris"
        int win_x         = 100
        int win_y         = 100
        int win_w         = 400
        int win_h         = 800
        int win_flags     = 0

        int window_id     = 0
        int renderer_id   = 0

        ptr board         = null
        int board_w       = 10
        int board_h       = 20
        int cell_size     = 40

        ptr pieces        = null
        int piece_id      = 0
        int rotation      = 0
        int piece_x       = 3
        int piece_y       = 0

        int timer         = 0
        int speed         = 350
        int tick          = 0
        int game_over     = 0
        int rand_seed     = 12345

        int i             = 0
        int j             = 0
        int k             = 0
        int v             = 0
        int idx           = 0
        int x             = 0
        int y             = 0
        int rax           = 0
        int rcx           = 0
        int eax           = 0
        int tmp_i         = 0
        int tmp_idx       = 0
        int tmp_j         = 0
        int tmp_v         = 0
        int tmp_px        = 0
        int tmp_py        = 0
        int tmp_x         = 0
        int tmp_y         = 0
        int tmp_idx2      = 0
        int m             = 0
        int tx            = 0
        int ty            = 0
        int ts            = 0
    }

    section code {
    start:
        call start_game
        done

    function start_game:
        call init
        call spawnPiece
        call gameLoop
        ret
        
    function init:
        invoke init, 0
        invoke create_window, title, win_x, win_y, win_w, win_h, win_flags
        return window_id
        invoke create_renderer, window_id, -1, 0
        return renderer_id
        mov i, board_w
        mul i, board_h
        alloc board, 8, i
        mov j, 0
    clear_loop:
        cmp j, i
        jge initPieces
        store 0, board, j
        add  j, 1
        jmp clear_loop

    initPieces:
        alloc pieces, 8, 112
        # I
        store 4,  pieces, 0
        store 5,  pieces, 1
        store 6,  pieces, 2
        store 7,  pieces, 3
        store 2,  pieces, 4
        store 6,  pieces, 5
        store 10, pieces, 6
        store 14, pieces, 7
        store 8,  pieces, 8
        store 9,  pieces, 9
        store 10, pieces, 10
        store 11, pieces, 11
        store 1,  pieces, 12
        store 5,  pieces, 13
        store 9,  pieces, 14
        store 13, pieces, 15
        # J
        store 1,  pieces, 16
        store 5,  pieces, 17
        store 6,  pieces, 18
        store 7,  pieces, 19
        store 2,  pieces, 20
        store 3,  pieces, 21
        store 6,  pieces, 22
        store 10, pieces, 23
        store 5,  pieces, 24
        store 6,  pieces, 25
        store 7,  pieces, 26
        store 11, pieces, 27
        store 2,  pieces, 28
        store 6,  pieces, 29
        store 10, pieces, 30
        store 9,  pieces, 31
        # L
        store 3,  pieces, 32
        store 5,  pieces, 33
        store 6,  pieces, 34
        store 7,  pieces, 35
        store 2,  pieces, 36
        store 6,  pieces, 37
        store 10, pieces, 38
        store 11, pieces, 39
        store 5,  pieces, 40
        store 6,  pieces, 41
        store 7,  pieces, 42
        store 9,  pieces, 43
        store 1,  pieces, 44
        store 2,  pieces, 45
        store 6,  pieces, 46
        store 10, pieces, 47
        # O
        store 5,  pieces, 48
        store 6,  pieces, 49
        store 9,  pieces, 50
        store 10, pieces, 51
        store 5,  pieces, 52
        store 6,  pieces, 53
        store 9,  pieces, 54
        store 10, pieces, 55
        store 5,  pieces, 56
        store 6,  pieces, 57
        store 9,  pieces, 58
        store 10, pieces, 59
        store 5,  pieces, 60
        store 6,  pieces, 61
        store 9,  pieces, 62
        store 10, pieces, 63
        # S
        store 2,  pieces, 64
        store 3,  pieces, 65
        store 5,  pieces, 66
        store 6,  pieces, 67
        store 1,  pieces, 68
        store 5,  pieces, 69
        store 6,  pieces, 70
        store 10, pieces, 71
        store 6,  pieces, 72
        store 7,  pieces, 73
        store 9,  pieces, 74
        store 10, pieces, 75
        store 2,  pieces, 76
        store 6,  pieces, 77
        store 7,  pieces, 78
        store 11, pieces, 79
        # T
        store 2,  pieces, 80
        store 5,  pieces, 81
        store 6,  pieces, 82
        store 7,  pieces, 83
        store 2,  pieces, 84
        store 6,  pieces, 85
        store 7,  pieces, 86
        store 10, pieces, 87
        store 5,  pieces, 88
        store 6,  pieces, 89
        store 7,  pieces, 90
        store 10, pieces, 91
        store 2,  pieces, 92
        store 5,  pieces, 93
        store 6,  pieces, 94
        store 10, pieces, 95
        # Z
        store 1,  pieces, 96
        store 2,  pieces, 97
        store 6,  pieces, 98
        store 7,  pieces, 99
        store 3,  pieces, 100
        store 6,  pieces, 101
        store 7,  pieces, 102
        store 10, pieces, 103
        store 5,  pieces, 104
        store 6,  pieces, 105
        store 10, pieces, 106
        store 11, pieces, 107
        store 2,  pieces, 108
        store 5,  pieces, 109
        store 6,  pieces, 110
        store 9,  pieces, 111
        mov rax, window_id
        ret

    function spawnPiece:
        mov v, rand_seed
        mul v, 1103515245
        add v, 12345
        mov rand_seed, v

        mov v, rand_seed
        div v, 65536
        mod v, 7
        mov piece_id, v
        cmp piece_id, 0
        jge piece_id_ok
        add piece_id, 7
    piece_id_ok:

        mov rotation, 0
        mov piece_x, 3
        mov piece_y, 0

        mov rax, piece_x
        mov rcx, piece_y
        call checkCollision
        cmp rax, 1
        je setGameOver
        mov rax, 0
        ret
    setGameOver:
        mov game_over, 1
        mov rax, 1
        ret

    function gameLoop:
    gloop:
        cmp game_over, 1
        je over
        call handleInput
        call update
        call render
        jmp gloop
    over:
        call quit
        ret

    function handleInput:
    input_loop:
        invoke poll_event
        return eax
        cmp eax, 0
        je end_poll
        invoke get_event_type
        return eax
        cmp eax, 768
        jne input_loop
        invoke get_key_code
        return eax
        mov k, eax
        cmp k, 27         # ESC to quit
        je quit_app
        cmp k, 97         # 'a' for left
        je moveLeft
        cmp k, 115        # 's' for right
        je moveRight
        cmp k, 100        # 'd' for down
        je doMoveDown
        cmp k, 32         # space for rotate
        je rotatePiece
        jmp input_loop
    quit_app:
        call quit
        ret
    moveLeft:
        mov rax, piece_x
        sub rax, 1
        mov rcx, piece_y
        call checkCollision
        cmp rax, 0
        je doMoveLeft
        mov rax, 0
        ret
    doMoveLeft:
        sub piece_x, 1
        mov rax, 1
        ret
    moveRight:
        mov rax, piece_x
        add rax, 1
        mov rcx, piece_y
        call checkCollision
        cmp rax, 0
        je doMoveRight
        mov rax, 0
        ret
    doMoveRight:
        add piece_x, 1
        mov rax, 1
        ret
    rotatePiece:
        mov v, rotation
        add v, 1
        mod v, 4
        mov rotation, v
        mov rax, piece_x
        mov rcx, piece_y
        call checkCollision
        cmp rax, 0
        je doRotate
        mov rax, 0
        ret
    doMoveDown:
        call moveDown
        ret
    doRotate:
        mov rax, 1
        ret
    end_poll:
        mov rax, 0
        ret

    function update:
        add tick, 1
        cmp tick, speed
        jl end_update
        mov tick, 0         # Reset tick after reaching speed
        call moveDown
    end_update:
        mov rax, 0
        ret

    function moveDown:
        mov rax, piece_x
        mov rcx, piece_y
        add rcx, 1
        call checkCollision
        cmp rax, 0
        je move_down_yes
        # else, collision: lock and spawn new piece
        call lockPiece
        call clearLines
        call spawnPiece
        mov rax, 0
        ret
    
    move_down_yes:         # Renamed and inside the function
        add piece_y, 1
        mov rax, 1
        ret                # Now this ret belongs to moveDown

    function render:
        invoke set_draw_color, renderer_id, 0, 0, 0, 255
        invoke clear, renderer_id

        mov y, 0
    board_loop_y:
        cmp y, board_h
        jge drawPiece
        mov x, 0
    board_loop_x:
        cmp x, board_w
        jge next_row
        mov idx, y
        mul idx, board_w
        add idx, x
        load v, board, idx
        cmp v, 0
        je next_cell
        call drawCell
    next_cell:
        add x, 1
        jmp board_loop_x
    next_row:
        add y, 1
        jmp board_loop_y

    drawPiece:
        mov i, 0
    piece_loop:
        cmp i, 4
        jge present
        mov idx, piece_id
        mul idx, 16
        mov j, rotation
        mul j, 4
        add idx, j
        add idx, i
        load v, pieces, idx
        mov tmp_py, v
        div tmp_py, 4
        mov tmp_px, v
        mod tmp_px, 4
        mov x, piece_x
        add x, tmp_px
        mov y, piece_y
        add y, tmp_py
        cmp y, 0
        jl skip_draw
        mov k, piece_id
        add k, 1
        call drawCell
    skip_draw:
        add i, 1
        jmp piece_loop

    present:
        invoke present, renderer_id
        mov rax, 0
        ret

    function drawCell:
        mov m, k
        mul m, 35
        mov j, 255
        sub j, m
        mov k, 128
        add k, m
        invoke set_draw_color, renderer_id, m, j, k, 255
        mov tx, x
        mul tx, cell_size
        mov ty, y
        mul ty, cell_size
        mov ts, cell_size
        sub ts, 1
        invoke fill_rect, renderer_id, tx, ty, ts, ts
        mov rax, 0
        ret

    function lockPiece:
        mov i, 0
    lock_loop:
        cmp i, 4
        jge end_lock
        mov idx, piece_id
        mul idx, 16
        mov j, rotation
        mul j, 4
        add idx, j
        add idx, i
        load v, pieces, idx
        mov tmp_py, v
        div tmp_py, 4
        mov tmp_px, v
        mod tmp_px, 4
        mov x, piece_x
        add x, tmp_px
        mov y, piece_y
        add y, tmp_py
        cmp y, 0
        jl skip_lock
        cmp y, board_h
        jge skip_lock
        mov tmp_idx2, y
        mul tmp_idx2, board_w
        add tmp_idx2, x
        mov v, piece_id
        add v, 1
        store v, board, tmp_idx2
    skip_lock:
        add i, 1
        jmp lock_loop
    end_lock:
        mov rax, 0
        ret

    function clearLines:
        mov y, board_h
        sub y, 1
    line_check_loop:
        cmp y, 0
        jl end_clear
        mov k, 1
        mov x, 0
    row_check_loop:
        cmp x, board_w
        jge check_full
        mov idx, y
        mul idx, board_w
        add idx, x
        load v, board, idx
        cmp v, 0
        jne next_cell_in_row
        mov k, 0
    next_cell_in_row:
        add x, 1
        jmp row_check_loop
    check_full:
        cmp k, 1
        jne next_line
        mov j, y
    shift_loop:
        cmp j, 0
        jle clear_top
        mov x, 0
    copy_row:
        cmp x, board_w
        jge next_shift
        mov tmp_idx2, j
        sub tmp_idx2, 1
        mul tmp_idx2, board_w
        add tmp_idx2, x
        load v, board, tmp_idx2
        mov idx, j
        mul idx, board_w
        add idx, x
        store v, board, idx
        add x, 1
        jmp copy_row
    next_shift:
        sub j, 1
        jmp shift_loop
    clear_top:
        mov x, 0
    clear_top_loop:
        cmp x, board_w
        jge end_shift
        store 0, board, x
        add x, 1
        jmp clear_top_loop
    end_shift:
        add y, 1
    next_line:
        sub y, 1
        jmp line_check_loop
    end_clear:
        mov rax, 0
        ret

    function checkCollision:
        mov tmp_i, 0
    check_loop:
        cmp tmp_i, 4
        jge no_collision
        mov tmp_idx, piece_id
        mul tmp_idx, 16
        mov tmp_j, rotation
        mul tmp_j, 4
        add tmp_idx, tmp_j
        add tmp_idx, tmp_i
        load tmp_v, pieces, tmp_idx
        mov tmp_py, tmp_v
        div tmp_py, 4
        mov tmp_px, tmp_v
        mod tmp_px, 4
        mov tmp_x, rax
        add tmp_x, tmp_px
        mov tmp_y, rcx
        add tmp_y, tmp_py
        cmp tmp_x, 0
        jl collision
        cmp tmp_x, board_w
        jge collision
        cmp tmp_y, board_h
        jge collision

        # If block is above board (y < 0), it's not a collision (yet), so skip board check
        cmp tmp_y, 0
        jl next_check

        # Only check board cell if the block is actually on the board
        mov tmp_idx2, tmp_y
        mul tmp_idx2, board_w
        add tmp_idx2, tmp_x
        load tmp_v, board, tmp_idx2
        cmp tmp_v, 0
        jne collision
    next_check:
        add tmp_i, 1
        jmp check_loop
    no_collision:
        mov rax, 0
        ret
    collision:
        mov rax, 1
        ret

    function quit:
        free board
        free pieces
        invoke destroy_renderer, renderer_id
        invoke destroy_window, window_id
        invoke quit
        exit 0
        ret
    }
}
